// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rentals.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createRental = `-- name: CreateRental :one
INSERT INTO rentals (user_id, tape_id)
VALUES(
  $1,
  $2
)
RETURNING id, public_id, created_at, user_id, tape_id, rented_at, returned_at
`

type CreateRentalParams struct {
	UserID int32
	TapeID int32
}

func (q *Queries) CreateRental(ctx context.Context, arg CreateRentalParams) (Rental, error) {
	row := q.db.QueryRowContext(ctx, createRental, arg.UserID, arg.TapeID)
	var i Rental
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.CreatedAt,
		&i.UserID,
		&i.TapeID,
		&i.RentedAt,
		&i.ReturnedAt,
	)
	return i, err
}

const getActiveRentalByUser = `-- name: GetActiveRentalByUser :many
SELECT id, public_id, created_at, user_id, tape_id, rented_at, returned_at FROM rentals
WHERE user_id = $1 AND returned_at IS NULL
`

// NULL is not a value so only IS keyword works
func (q *Queries) GetActiveRentalByUser(ctx context.Context, userID int32) ([]Rental, error) {
	rows, err := q.db.QueryContext(ctx, getActiveRentalByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rental
	for rows.Next() {
		var i Rental
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.CreatedAt,
			&i.UserID,
			&i.TapeID,
			&i.RentedAt,
			&i.ReturnedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveRentalCountByTape = `-- name: GetActiveRentalCountByTape :one
SELECT COUNT(*) FROM rentals
WHERE tape_id = $1 AND returned_at IS NULL
`

func (q *Queries) GetActiveRentalCountByTape(ctx context.Context, tapeID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getActiveRentalCountByTape, tapeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getActiveRentalCountByUser = `-- name: GetActiveRentalCountByUser :one
SELECT COUNT(*) FROM rentals
WHERE user_id = $1 AND returned_at IS NULL
`

func (q *Queries) GetActiveRentalCountByUser(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getActiveRentalCountByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getActiveRentalbyTape = `-- name: GetActiveRentalbyTape :many
SELECT id, public_id, created_at, user_id, tape_id, rented_at, returned_at FROM rentals
WHERE tape_id = $1 AND returned_at IS NULL
`

func (q *Queries) GetActiveRentalbyTape(ctx context.Context, tapeID int32) ([]Rental, error) {
	rows, err := q.db.QueryContext(ctx, getActiveRentalbyTape, tapeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rental
	for rows.Next() {
		var i Rental
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.CreatedAt,
			&i.UserID,
			&i.TapeID,
			&i.RentedAt,
			&i.ReturnedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllActiveRentals = `-- name: GetAllActiveRentals :many
SELECT
  rentals.id, rentals.public_id, rentals.created_at, rentals.user_id, rentals.tape_id, rentals.rented_at, rentals.returned_at,
  tapes.title,
  users.username
FROM rentals
JOIN tapes ON rentals.tape_id = tapes.id
JOIN users ON rentals.user_id = users.id
WHERE returned_at IS NULL
ORDER BY rentals.created_at ASC
`

type GetAllActiveRentalsRow struct {
	ID         int32
	PublicID   uuid.UUID
	CreatedAt  time.Time
	UserID     int32
	TapeID     int32
	RentedAt   time.Time
	ReturnedAt sql.NullTime
	Title      string
	Username   string
}

func (q *Queries) GetAllActiveRentals(ctx context.Context) ([]GetAllActiveRentalsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllActiveRentals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllActiveRentalsRow
	for rows.Next() {
		var i GetAllActiveRentalsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.CreatedAt,
			&i.UserID,
			&i.TapeID,
			&i.RentedAt,
			&i.ReturnedAt,
			&i.Title,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const returnTape = `-- name: ReturnTape :exec
UPDATE rentals
SET returned_at = $2
WHERE id = $1
`

type ReturnTapeParams struct {
	ID         int32
	ReturnedAt sql.NullTime
}

func (q *Queries) ReturnTape(ctx context.Context, arg ReturnTapeParams) error {
	_, err := q.db.ExecContext(ctx, returnTape, arg.ID, arg.ReturnedAt)
	return err
}
