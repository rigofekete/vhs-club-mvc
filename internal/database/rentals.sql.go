// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rentals.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createRental = `-- name: CreateRental :one
INSERT INTO rentals (id, created_at, user_id, tape_id, rented_at, returned_at)
VALUES(
  gen_random_uuid(),
  NOW(),
  $1,
  $2,
  NOW(),
  $3
)
RETURNING id, created_at, user_id, tape_id, rented_at, returned_at
`

type CreateRentalParams struct {
	UserID     uuid.UUID
	TapeID     uuid.UUID
	ReturnedAt sql.NullTime
}

func (q *Queries) CreateRental(ctx context.Context, arg CreateRentalParams) (Rental, error) {
	row := q.db.QueryRowContext(ctx, createRental, arg.UserID, arg.TapeID, arg.ReturnedAt)
	var i Rental
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UserID,
		&i.TapeID,
		&i.RentedAt,
		&i.ReturnedAt,
	)
	return i, err
}

const getActiveRentalByID = `-- name: GetActiveRentalByID :many
SELECT id, created_at, user_id, tape_id, rented_at, returned_at FROM rentals
WHERE user_id = $1 AND returned_at IS NULL
`

// NULL is not a value so only IS keyword works
func (q *Queries) GetActiveRentalByID(ctx context.Context, userID uuid.UUID) ([]Rental, error) {
	rows, err := q.db.QueryContext(ctx, getActiveRentalByID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rental
	for rows.Next() {
		var i Rental
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UserID,
			&i.TapeID,
			&i.RentedAt,
			&i.ReturnedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveRentalbyTape = `-- name: GetActiveRentalbyTape :many
SELECT id, created_at, user_id, tape_id, rented_at, returned_at FROM rentals
WHERE tape_id = $1 AND returned_at IS NULL
`

func (q *Queries) GetActiveRentalbyTape(ctx context.Context, tapeID uuid.UUID) ([]Rental, error) {
	rows, err := q.db.QueryContext(ctx, getActiveRentalbyTape, tapeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rental
	for rows.Next() {
		var i Rental
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UserID,
			&i.TapeID,
			&i.RentedAt,
			&i.ReturnedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const returnTape = `-- name: ReturnTape :exec
UPDATE rentals
SET returned_at = $2
WHERE id = $1
`

type ReturnTapeParams struct {
	ID         uuid.UUID
	ReturnedAt sql.NullTime
}

func (q *Queries) ReturnTape(ctx context.Context, arg ReturnTapeParams) error {
	_, err := q.db.ExecContext(ctx, returnTape, arg.ID, arg.ReturnedAt)
	return err
}
